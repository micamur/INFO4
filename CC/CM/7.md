# CC 7 - Problèmes NP-complets

Chaîne YouTube Undefined Behaviour : <https://www.youtube.com/channel/UCZ4oRX0e157gHeJHp0XOULA>

## Problèmes de décision et d'optimisation

Qu'est-ce qu'un problème ?

**Définition.** Un **problème** est un ensemble d'instances et une "réponse" pour chacune de ces instances.

*Exemples.*

- Plus court chemin (optimisation).
  - Instances. un graphe orienté $$\vec{G}$$, avec des poids sur les arcs et deux sommets $$u$$ et $$v$$ de $$\vec{G}$$.
  - Réponse. Le poids d'un plus court chemin de $$u$$ à $$v$$.
- Flot maximal (optimisation).
  - Instances. Un graphe orienté $$\vec{G}$$, muni d'une fonction $$c$$ de capacité sur les arcs et une source $$s$$ et un puits $$t$$.
  - Réponse. Valeur d'un flot maximal.
- $$k$$-coloration (décision).
- Chemin hamiltonien (décision).

**Définition.** Un **problème de décision** est un problème dont la réponse est oui ou non.

**Définition.** Un **problème d'optimisation** est un problème dans lequel on cherche à maximiser ou minimiser une certaine mesure et dont la réponse est la valeur optimale de la mesure.

Quand on a un problème d'optimisation on peut toujours se ramener à un problème de décision : on introduit une valeur numérique dans le problème de décision pour correspondre à la mesure à optimiser.

*Exemple.* Passage d'optimisation à décision.

- Flot maximal (décision).
  - Instances. Un graphe orienté $$\vec{G}$$, muni d'une fonction $$c$$ de capacité sur les arcs, une source $$s$$, un puits $$t$$ et $$k \in \mathbb{N}$$.
- Question. Est-ce qu'il existe un flot de valeur $$\geq k$$ ?

Si on sait résoudre un problème d'optimisation, on sait résoudre le problème de décision associé.

Si on sait résoudre le problème de décision et qu'on peut borner (expérimentalement) la valeur optimale du problème d'optimisation, on sait résoudre le problème d'optimisation.

**Définition.** La **complexité d'un problème** est la complexité du meilleur algorithme possible pouvant le résoudre.

**Définition.** La **classe de complexité** est un ensemble de problèmes qui partagent des complexités similaires.

## Classe *P*

**Définition.** La classe de complexité $$P$$ regroupe les problèmes dont la complexité est $$O(n^k)$$ pour $$k \in \mathbb{N}$$.

*Exemple.* Problèmes dans la classe $$P$$.

- Flot maximal (décision)
- 2-coloration
- Est premier $$\rightarrow$$ crible d'Ératosthène
  - On divise par tous les nombres de $$2$$ à $$\sqrt{n}$$
  - Complexité de $$n^{1/2}$$
  - Complexité de $$2^{\lceil \log n \rceil / 2}$$, $$\lceil \log n \rceil$$  taille de l'entrée.
- Graphe eulérien
- Existence d'un couplage parfait
- Reconnaissance d'un arbre

**Théorème.** Agrawal, Kayal et Sayema, 2002. Est premier peut être résolu en temps $$O(\log (n)^{1/2})$$.

Pourquoi la classe *P* ?

Pas de gros *gap* de complexité entre $$n^k$$ et $$n^{k+1}$$.

*Problème de la taille de l'instance.* Si pour passer d'une complexité "réelle" à une complexité théorique il y a une fonction polynomiale, on reste dans la même classe.

## Classe *NP*

**Définition.** Pour une instance positive (on répond oui) $$A$$ d'un problème de décision $$\mathcal{A}$$, un **certificat polynomial** est une séquence de caractères de taille polynomiale en $$|A|$$ et telle qu'il existe un algorithme polynomial en $$|A|$$ qui permet de vérifier que $$A$$ est bien positive.

Moins formellement, un certificat est une solution que l'on peut "facilement" vérifier.

**Définition.** La classe *NP* est la classe des problèmes pour lesquels chaque instance positive admet un certificat.

*Exemples.* 3-coloration, chemin hamiltonien

**Définition.** Un **algorithme non déterministe** est un algorithme qui a certaines étapes de son exécution peut faire appel à un générateur aléatoire. Il réussit s'il existe une séquence de tirage aléatoire tes qu'il renvoie le résultat voulu.

**Théorème.** Un problème est dans *NP* si et seulement si il admet un algorithme non déterministe polynomial pour prouver les instances positives.

*Preuve.* Non déterministe $$\Rightarrow$$ *NP*

- Certificats : séquence aléatoire qui permettent de prouver les instances.
- Algorithme : algo non déterministe dans lequel on remplace chaque appel aléatoire par la valeur du certificat.
- NP : non déterministe, on titre un certificat au hasard puis on applique l'algorithme de vérification.

**Théorème.** *P* $$\subseteq$$ *NP*

*Preuve.* Soit $$\mathcal{A} \in$$ *P*, soit $$A$$ une instance de $$\mathcal{A}$$. Il existe un algorithme polynomial pour résoudre $$A$$. Donc si $$A$$ est positif, le certificat $$\Phi$$ permet la vérification.

*Exemple.* Problème pas dans *NP* : les échecs, le go.

Pourquoi la classe NP ? Quasiment tous les problèmes pratiques plus petits. Candidat à la non polynomialité.

***P* vs *NP*.** Est-ce que *P* = *NP* ? Un des problèmes du millénaire. Si c'est vrai, alors le système de clés publiques et clés privées est cassé !

## Réduction

**Définition.** Un problème de décision $$\mathcal{A}$$ se réduit à un problème de décision $$\mathcal{B}$$ en temps polynomial s'il existe un algorithme polynomial $$f$$ sur les instances de $$\mathcal{A}$$ tel que pour toute instance $$A$$ de $$\mathcal{A}$$ :

- $$f(A)$$ est une instance de $$\mathcal{B}$$
- $$f(A)$$ est positive pour $$\mathcal{B}$$ ssi $$A$$ est positive pour $$\mathcal{A}$$

*Notation.* $$\mathcal{A} \leq {}_p \mathcal{B}$$ = $$\mathcal{A}$$ se réduit à $$\mathcal{B}$$ en temps polynomial

**Théorème.** Soit $$\mathcal{A}$$ et $$\mathcal{B}$$ deux problèmes de décision avec $$\mathcal{A} \leq {}_p \mathcal{B}$$. Si $$\mathcal{B} \in P$$ alors $$\mathcal{A} \in P$$.

*Preuve.*

- Comme $$\mathcal{B} \in P$$, il existe un algorithme $$g$$ qui résoud $$\mathcal{B}$$ en temps polynomial.
- Comme $$\mathcal{A} \leq _p \mathcal{B}$$ en temps polynomial, il existe un algorithme de réduction polynomial $$f$$

Un algorithme polynomial pour résoudre le problème $$\mathcal{A}$$ est le suivant :

- Soit $$A$$ une instance de $$\mathcal{A}$$, on applique l'algorithme $$f$$ à $$A$$, on obtient une instance $$B$$ de $$\mathcal{B}$$.
- On applique l'algorithme $$g$$ à $$B$$ et on renvoie le même résultat. Comme $$f$$ est polynomial, la taille de $$B$$ est polynomial, la taille de $$B$$ est polynomial par rapport à la taille de $$A$$.
- Donc cet algorithme résout $$\mathcal{A}$$ en temps polynomial. $$\blacksquare$$

> On veut créer un algotithme polynomial pour résoudre $$A$$. $$f$$ est bien polynomial en la taille de $$A$$ et $$g$$ en la taille de $$f(A)$$.

$$T(f) = O(n^h) \Rightarrow |f(A)| = O(n^h)$$

$$T(g) = O(n^{h'}) \Rightarrow |g(f)| = O(n^{h \times h'})$$

Donc algorithme polynomial.

*Exemple de réduction.*  Soit $$k \in \mathbb{N}$$ pour la $$k$$-coloration.

- Entrée. Un graphe $$G = (V, E)$$
- Question. Est-il possible de colorer $$G$$ avec $$k$$ couleurs ?
- $$k\text{COL} \leq p(k+1)\text{COL} \; \forall k$$
- Réduction. Soit $$G$$ un graphe (instance de $$k$$-COL). On veut le graphe $$G' = (V', E')$$ avec $$V' = V \cup \{u\}$$ et $$E' = E \cup \{uv | v \in V(G)\}$$.
- La réduction est bien polynomiale en $$O(V(G))$$  (on rajoute $$n$$ arêtes):
  - Si $$G$$ admet une coloration avec $$k$$ couleurs, alors $$G'$$ a une coloration avec $$k+1$$ couleurs en ajoutant une couleur différente pour $$u$$.
  - Si $$G'$$ admet une coloration avec $$k+1$$ couleurs, $$u$$ est forcément d'une couleur différente de tous les autres sommets et en retirant $$u$$ on obtient une $$k$$-coloration de $$G$$

**Résumé.** $$G$$ est vrai pour le problème $$A$$ ssi $$G'$$ est vrai pour le problème $$B$$, et $$f$$ polynomial.

## Problème *NP*-complet

> En gros : $$\text{P} \subset \text{NP} \subset \text{EXP}$$, $$\text{NP-difficile}$$ traverse $$\text{NP}$$, $$\text{EXP}$$ et $$\text{NP-difficile}$$ et $$\text{NP-difficile} \cup \text{NP} = \text{NP-complet}$$.

**Définition.** Un problème $$\mathcal{A}$$ est **NP-difficile** si pour tous les problèmes $$\mathcal{B}$$ de NP, $$\mathcal{B} \leq {}_p \mathcal{A}$$.

"Un problème $$\mathcal{A}$$ est NP-difficile s'il est okus difficile que tous les problèmes de NP."

**Définition.** Les problèmes **NP-complets** sont les problèmes qui sont à la fois dans NP et NP-difficiles.

Si $$\mathcal{A}$$ est NP-difficile alors $$\mathcal{A} \in$$ NP et $$\forall \mathcal{B} \in$$ NP, $$\mathcal{B} \leq {}_p\mathcal{A}$$.

En particulier, si $$\mathcal{A}$$ et $$\mathcal{B}$$ sont NP-complets, $$\mathcal{A} \leq {}_p \mathcal{B}$$ et $$\mathcal{B} \leq {}_p \mathcal{A}$$.

L'existence de problèmes NP-complets n'est pas triviale, il pourrait exister $$\mathcal{A}_1 \leq {}_p\mathcal{A}_2 \leq ... \leq {}_p\mathcal{A}_1$$ mais il n'existe pas de telle séquence car il existe des problèmes NP-complets.

**Théorème.** **Cook-Levin (1971).** Le problème SAT est NP-complet.

Étand donné un ensemble de variables logiques $$x_1\; ...\; x_n$$ avec $$x_i \in {\text{VRAI}, \text{FAUX}}$$. Un **littéral** est soit $$x_i$$ soit $$\overline{x_i}$$ pour un certain $$i$$.

Une **clause** est le "ou" de plusieurs littéraux.

$$C = x_1 \lor x_2 \lor \overline{x_4}$$

Une formule logique sous **forme normale conjonctive** (*CNF*) est le "et" de plusieurs clauses.

$$F = (x_1 \lor x_2 \lor \overline{x_4}) \land (\overline{x_1} \lor x_3 \lor \overline{x_5}) \land (x_2 \lor x_4)$$

$$X = \{x_1, x_2, x_3, x_4, x_5\}$$

Une CNF est **satisfiable** s'il existe une assignation des variables à VRAI ou FAUX telle que la formule vale VRAI.

$$F$$ est satisfiable avec une assignation possible : $$\{x_1, x_2, x_3, x_4, x_5\} = \{\text{VRAI}, \text{FAUX}, \text{VRAI}, \text{VRAI}, \text{FAUX}\}$$

Le problème SAT est le suivant :

- Entrée. Une CNF F sur un ensemble de variables $$\{x_1, x_2, x_3, x_4, x_5\}$$ avec des clauses $$c_1 \; ... \; c_n$$.
- Question. $$F$$ est satisfiable ?
- Par exemple, $$F_2 = (x_1 \lor x_2) \land (x_1 \lor \overline{x_2}) \land (\overline{x_1} \lor x_2) \land (\overline{x_1} \lor \overline{x_2})$$ n'est pas satisfiable.

**Corollaire.** Si SAT peut être résolu en temps polynomial, alors P = NP.

*Preuve.* Soit $$\mathcal{A}$$ un problème de NP, comme SAT est NP complet, $$\mathcal{A} \leq {}_p \text{SAT}$$. Si SAT est polynomial alors $$\mathcal{A}$$ l'est aussi.

> *Remarque.* Pour prouver qu'un problème $$\mathcal{A}$$ est NP-complet, il faut :
>
> 1. Montrer qu'il est dans NP
> 2. Montrer qu'il existe un problème NP complet $$\mathcal{B}$$ tel que $$\mathcal{B} \leq {}_p \mathcal{A}$$

*Preuve du point 2.* $$\forall C \in$$ NP, $$C \leq {}_p \mathcal{B}$$ donc il existe un algorithme polynomial pour réduire $$C$$ à $$\mathcal{B}$$ : $$f$$. Comme $$\mathcal{B} \leq {}_p \mathcal{A}$$ il existe un algo de réduction $$g$$. $$g(f(C))$$ réduit $$C$$ à $$\mathcal{A}$$ en temps polynomial.

*Problème 3-SAT.*

- Instance. Une formule CNF $$F$$ sur un ensemble de variables $$\{x_1 \; ; ... \; x_n\}$$ et un ensemble de clauses $$c_1 \; ... \; c_n$$ telles que chaque clause contient au plus 3 littéraux.
- Question. Est-ce que $$F$$ est satisfiable ?

**Théorème.** **Karp, 1972.** 3-SAT est NP-complet.

*Preuve.*

1. **3-SAT $$\in$$ NP** car une instance positive aura comme certificat son assignation des variables.
2. **SAT $$\leq {}_p$$ 3-SAT**. Soit $$F$$ une instance de SAT. Soit $$c_j$$ une clause de $$F$$ contenant $$k$$ littéraux. Soit $$c_j = (l_1 \lor l_2 \lor ... \lor l_k)$$ avec $$l_j = x_{ij} \text{ ou } \overline{x_{ij}}$$ pour une variable $$x_{ij}$$.
  - Supposons que $$k$$ est impair. On rajoute $$k$$ variables $$y_{j1}, y_{j2}, \; ..., y_{jk}$$ et on transforme la clause $$c_j$$ en $$k$$ clauses de taille 3 : $$(y_{j1} \lor l_1 \lor \overline{y_{j2}}) \land (y_{j2} \lor l_2 \lor \overline{y_{j3}}) \land ... \land (y_{jk} \lor l_k \lor \overline{y_{j1}})$$.
  - Supposons que $$k$$ est pair. On rajoute $$k+1$$ variables $$y_{j1}, y_{j2}, \; ..., y_{j(k+1)}$$ et on transforme la clause $$c_j$$ en $$k+1$$ clauses de taille 3 (sauf pour la dernière, 2) : $$(y_{j1} \lor l_1 \lor \overline{y_{j2}}) \land (y_{j2} \lor l_2 \lor \overline{y_{j3}}) \land ... \land (y_{jk} \lor l_k \lor \overline{y_{j(k+1)}}) \land (y_{j(k+1)} \lor \overline{y_{j1}})$$.
  - Soit $$n$$ le nombre de variables et $$m$$ le nombre de clauses :
    - La taille de l'instance de SAT est $$O(n \times m)$$
    - La taille de l'instance transformée est $$O(n \times (n \times m))$$
  - Si l'instance de SAT admet une assignation qui la satisfait, on peut trouver une bonne assignation de 3-SAT. Inversement, si c'est impossible, alors on ne peut pas trouver de bonne assignation de 3-SAT.

.
